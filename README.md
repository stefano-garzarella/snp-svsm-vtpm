# AMD SEV-SNP PoC with SVSM, KBS proxy, virtio-blk device, and stateful vTPM

This PoC will allow you to start a Confidential VM on AMD SEV-SNP.

In this demo we will see how SVSM can be used to emulate a stateful vTPM (EK keys
and EV state are preserved at each boot).

The vTPM state is saved encrypted in the SVSM state file and exposed to SVSM
as a virtio-blk device over MMIO.
Remote attestation is used to get the SVSM state key after a successful attestation.

This PoC is based on the following Coconut SVSM PRs:
- https://github.com/coconut-svsm/svsm/pull/635
- https://github.com/coconut-svsm/svsm/pull/528

This repository can be used for the following demos:

- [Demo 1: Check memory encryption](#demo-1-check-memory-encryption)
- [Demo 2: Use a stateful vTPM to automatically mount an encrypted rootfs](#demo-2-use-a-stateful-vtpm-to-automatically-mount-an-encrypted-rootfs)
- [Demo 3: Additional uses of the vTPM](#demo-3-additional-uses-of-the-vtpm)

## Prerequisites

This POC was tested on Fedora 41 and Fedora 42.

### Host machine

For running this demo, you need the host machine with:
- AMD processor that supports SEV-SNP
- Coconut Linux kernel installed, you can build it yourself or install it
  via copr in Fedora:
  - Coconut source kernel code.  
    You can build the host kernel by following the instructions here:
    https://github.com/coconut-svsm/svsm/blob/main/Documentation/INSTALL.md#preparing-the-host
  - Fedora copr package  
```shell
sudo dnf copr enable -y @virtmaint-sig/sev-snp-coconut
sudo dnf install kernel-snp-coconut
```

### Build machine

This repository contains the QEMU code, EDK2 code, MS TPM simulator, and several
Rust projects, so I recommend that you install the following packages
(for Fedora 41) to use the scripts contained in this demo:

```shell
sudo dnf builddep https://src.fedoraproject.org/rpms/qemu/raw/f41/f/qemu.spec
sudo dnf builddep https://src.fedoraproject.org/rpms/edk2/raw/f41/f/edk2.spec
sudo dnf install cargo rust rust-std-static-x86_64-unknown-none \
                 autoconf automake autoconf-archive \
                 buildah podman cbindgen bindgen-cli CUnit-devel openssl \
                 sqlite-devel virt-install ncat awk script xxd
```

## Build all components

### Build QEMU, EDK2, IGVM libraries, and SVSM

This operation is only required the first time, or when git submodules are updated

```shell
./prepare.sh

# Clean up everything generated by this demo (including VM image,
# SVSM state, etc.) previously, and rebuild QEMU, EDK2, IGVM, and SVSM.
./prepare.sh -c
```

### Build the guest image with an encrypted rootfs

This is only required the first time or when you want to regenerate a new
image (for example, with a different encryption key).

The script will also install the coconut kernel for the guest, put the
`tpm` module in the initrd, and configure `/etc/crypttab` to use the TPM
to unseal the LUKS key.

```shell
# Default LUKS passphrase used: MY-LUKS-PASSPHRASE
./build-vm-image.sh

# Or you can specify your
./build-vm-image.sh --passphrase <custom LUKS passphrase>
```

## Start Key Broker Service (KBS)

SVSM needs to maintain a persistent state across reboots.
This state is encrypted to ensure it remains inaccessible to the host.
As a result, SVSM must communicate with a Key Broker Service (KBS) to perform
attestation and obtain the decryption key required to unlock its state.

### Start Key Broker server and SVSM proxy

This script starts in the host the Key Broker server (it will be remote in a
real scenario) and the proxy used by SVSM to communicate with the server.
The proxy forwards requests arriving from SVSM via a serial port to the http
connection with the server.

```shell
./start-kbs.sh
```

### Register launch measurement and the SVSM state key in the Key Broker server

This script first calculates the launch measurement (SVSM, OVMF, etc.) and then
registers it in the Key Broker server along with the SVSM state key (512 bits).

```shell
# we are using XTS for the encryption layer with AES256
# XTS requires two AES256 keys, so 512 bits (64 bytes) in total
SECRET="$(openssl rand -hex 64)"

./register-resource-in-kbs.sh -p "$SECRET"
```

## Demo 1: Check memory encryption

In this demo, we verify that the guest memory is encrypted and inaccessible
to the host.
We do this by dumping the guest's memory from the host side and attempting to
locate a known secret that was deliberately placed in memory.
If memory encryption is working correctly, the secret should not be
recoverable in plaintext from the dump.

The demo is performed on both a standard virtual machine and a confidential
virtual machine, allowing a direct comparison of behavior and security
guarantees.

### Scraping the memory of a non-confidential VM

Launch a non-confidential VM and then we write a secret in memory:

```shell
./start-no-cvm.sh

# LUKS passphrase is now required, since the TPM is absent:
# Please enter passphrase for disk QEMU_HARDDISK (luks-bf91e8fe-c1e3-4696-937f-51c83d312eb9)::
# MY-LUKS-PASSPHRASE or <custom LUKS passphrase>

echo "SECRET=424242" > /dev/shm/secret
```

Now let's go scrape the memory of the guest to see if we can find the secret.
The script simply asks QEMU to dump the VM's physical memory and then looks
in the file:

```shell
./secret-scraper.sh -s "SECRET=424242"
````

Memory is not encrypted, so in the output we will find our secret.

### Scraping the memory of a confidential VM (CVM)

Now let's do the same, but by launching a confidential VM (CVM):

```shell
./start-cvm.sh

# LUKS passphrase is now required, since the key is not yet sealed
# with the TPM:
# Please enter passphrase for disk QEMU_HARDDISK (luks-bf91e8fe-c1e3-4696-937f-51c83d312eb9)::
# MY-LUKS-PASSPHRASE or <custom LUKS passphrase>

echo "SECRET=424242" > /dev/shm/secret
```

Let's scrape the guest memory again:

```shell
./secret-scraper.sh -s "SECRET=424242"
````

This time we cannot read anything because the guest memory is encrypted.

## Demo 2: Use a stateful vTPM to automatically mount an encrypted rootfs

In this demo, we use the stateful vTPM provided by SVSM to seal the LUKS key of
the root filesystem to a specific set of PCRs.
The system is configured to automatically unseal the key and mount the encrypted
rootfs if the measured environment matches the expected policy.

We demonstrate how changing the kernel command line (which affects PCR9) will
cause the unseal operation to fail, preventing the rootfs from being mounted.

SVSM preserves its state (including vTPM NV Data) across reboots using an
encrypted state.
The key needed to unlock this disk is released by a Key Broker Service (KBS)
only after a successful attestation process, ensuring that the VM is running
in a trusted environment.

### Manufacture the MS TPM

This operation is only required the first time, or when we want to regenerate
the TPM state.
In this way, the TPM's EK are recreated and NV state reset, so all sealed
secrets can no longer be unsealed.

Note: We currently do not have a tool available, so the script clears the SVSM
state and launches a diskless CVM. In this way SVSM, finding the state empty,
generates a new vTPM.

```shell
./remanufacture-tpm.sh
```

### Start the Confidential VM

We can now launch our CVM. SVSM will receive the key from the Key Broker
server and can access its state by decrypting it.

```shell
./start-cvm.sh
```

### Seal the LUKS key with the TPM

#### First boot

If the VM disk is encrypted (for example, if it was generated with the script
included in this repo), the passphrase will be requested during the first boot:

```
Please enter passphrase for disk QEMU_HARDDISK (luks-bf91e8fe-c1e3-4696-937f-51c83d312eb9)::
# MY-LUKS-PASSPHRASE or <custom LUKS passphrase>
```

After entering the right passphrase, the rootfs will be mounted and we have
access to the CVM.

At this point we can take advantage of the stateful TPM emulated by SVSM to
unlock the disk at every boot.
Then, using `systemd-cryptenroll`, we can seal the LUKS passphrase with the TPM
and use different PCRs as policy.

```shell
# identify the LUKS encrypted volume
blkid -t TYPE=crypto_LUKS
/dev/sda3: UUID="bf91e8fe-c1e3-4696-937f-51c83d312eb9" TYPE="crypto_LUKS" PARTUUID="a7a021b0-f96d-431c-a94f-97ba8761228c"

# install the LUKS key for /dev/sda3 using as policy the PCRs 0,1,4,5,7,9
systemd-cryptenroll /dev/sda3 --wipe-slot=tpm2 --tpm2-device=auto \
  --tpm2-pcrs=0,1,4,5,7,9
# MY-LUKS-PASSPHRASE or <custom LUKS passphrase>
```

Rebooting CVM we can see how the LUKS passphrase is no longer required,
as it is sealed with the TPM:

```shell
poweroff

./start-cvm.sh

# LUKS passphrase no longer required, console will reach the login
```

#### Change the Linux `cmdline` to alter a PCR

Linux's cmdline is measured in PCR 9, so to see what happens when a policy
changes, let's alter the cmdline:

```shell
# read PCR 9
tpm2_pcrread sha256:9
  sha256:
    9 : 0xCA390570D8EE6298374E7223C3D5D4FF798731D6B9D1B542F564483A391FE4D4

# add a new parameter in the Linux cmdline
grubby --update-kernel=ALL --args="foo"
```

Rebooting CVM we find that the rootfs is no longer automatically unlocked,
as PCR 9 is different.


```shell
poweroff

./start-cvm.sh

# LUKS passphrase is now required, since PCR 9 is now different:
# Please enter passphrase for disk QEMU_HARDDISK (luks-bf91e8fe-c1e3-4696-937f-51c83d312eb9)::
# MY-LUKS-PASSPHRASE or <custom LUKS passphrase>
```

After entering the requested LUKS passphrase during boot, we can check the
PCR 9 and re-install the key:

```shell
# read PCR 9
tpm2_pcrread sha256:9
  sha256:
    9 : 0xC7824417EDF7422F2011931ECAC930B789AACAA6E68175622347736D71DEE920

# Update the LUKS key for /dev/sda3 using as policy the PCRs 0,1,4,5,7,9
systemd-cryptenroll /dev/sda3 --wipe-slot=tpm2 --tpm2-device=auto \
  --tpm2-pcrs=0,1,4,5,7,9
# MY-LUKS-PASSPHRASE or <custom LUKS passphrase>
```

At this point we can reboot and have the rootfs automatically unlock again
until the PCRs 0,1,4,5,7,9 are unchanged:

```shell
poweroff

./start-cvm.sh

# LUKS passphrase no longer required, console will reach the login
```

#### Re-manufacture the TPM

As we have seen, the LUKS passphrase is soldered with the TPM. This ensures
that if the TPM changes (e.g., it is re-manufactured), the new TPM will no
longer be able to unseal the secret.

So let's try re-manufacturing it. In this way the TPM's EK are regenerated and
NV state completely reset.

```shell
# Re-manufacture the MS TPM state
./remanufacture-tpm.sh

./start-cvm.sh

# LUKS passphrase is now required, since the TPM is re-manufactured:
# Please enter passphrase for disk QEMU_HARDDISK (luks-bf91e8fe-c1e3-4696-937f-51c83d312eb9)::
# MY-LUKS-PASSPHRASE or <custom LUKS passphrase>
```

Rebooting CVM we find that the rootfs is no longer automatically unlocked, as
the TPM is a new one. After entering the requested LUKS passphrase during
boot, we can re-install the key:

```shell
# Update the LUKS key for /dev/sda3 using as policy the PCRs 0,1,4,5,7,9
systemd-cryptenroll /dev/sda3 --wipe-slot=tpm2 --tpm2-device=auto \
  --tpm2-pcrs=0,1,4,5,7,9
# MY-LUKS-PASSPHRASE or <custom LUKS passphrase>
```

## Demo 3: Additional uses of the vTPM

### Install EK certificate in the vTPM NVRAM

The MS-TPM does not generate an EK certificate during manufacture, so
launching `tpm2_getekcertificate` or `tpm2_nvread 0x1c00002` in the CVM will
get an error.

In the future we will provide a tool to generate the EK certificate and
install it offline in the vTPM, but for now we can generate it directly in
the VM on the first boot:

```shell
./start-cvm.sh

git clone https://github.com/stefano-garzarella/tpm2_ek_cert_generator.git
cd tpm2_ek_cert_generator
make
```

At this point the EK certificate is written in the NVRAM, so the following
commands now works also after reboot:
```shell
tpm2_getekcertificate
tpm2_nvread 0x1c00002
```

The certificate is self-signed, but in this PoC we only use it to test the
vTPM functionality.

Note: The `tpm2_ek_cert_generator` installs the certificate in the owner
hierarchy, because the platform hierarchy is disabled by EDK2. When the script
for offline manufacturing will become available, we could use the platform
hierarchy.

### Seal and unseal secrets in the Confidential VM

#### Seal a secret

Now that we have the VM running with the vTPM, we can do secret sealing, also
linking it to certain PCRs.

```shell
PRIMARY_CTX=/tmp/current_primary.ctx
tpm2_createprimary -c "$PRIMARY_CTX"

tpm2_pcrread -Q -o pcr.bin sha256:0,1,2,3
tpm2_createpolicy --policy-pcr -l sha256:0,1,2,3 -f pcr.bin -L pcr.policy
echo "secret" | \
  tpm2_create -C "$PRIMARY_CTX" -L pcr.policy -i - -u seal.pub \
    -r seal.priv -c seal.ctx
```

This secret can only be released if the TPM state is preserved, so let's try
shutting down the VM and turning it back on:

```shell
poweroff

./start-cvm.sh
```

#### Unseal the secret after a reboot

```shell
PRIMARY_CTX=/tmp/current_primary.ctx
tpm2_createprimary -c "$PRIMARY_CTX"

tpm2_load -C "$PRIMARY_CTX" -u seal.pub -r seal.priv -c seal.ctx
tpm2_unseal -c seal.ctx -p pcr:sha256:0,1,2,3
```

If everything works, we should be able to see our “secret” after the last
command.

#### Re-manufacture the TPM

To see what happens if the state of the vTPM changes, let's try
re-manufacturing it. In this way the TPM's EK are regenerated and NV state
completely reset.

```shell
# Re-manufacture the MS TPM state
./remanufacture-tpm.sh

./start-cvm.sh
```

If we try the same steps as in the previous paragraph for unsealing, we see
that this fails because we basically have a new TPM.

```shell
$ tpm2_load -C "$PRIMARY_CTX" -u seal.pub -r seal.priv -c seal.ctx
WARNING:esys:src/tss2-esys/api/Esys_Load.c:324:Esys_Load_Finish() Received TPM Error 
ERROR:esys:src/tss2-esys/api/Esys_Load.c:112:Esys_Load() Esys Finish ErrorCode (0x000001df) 
ERROR: Eys_Load(0x1DF) - tpm:parameter(1):integrity check failed
```

#### Change the encryption key

The same behavior is also obtained by changing the encryption key registered in
KBS. In this way SVSM is unable to access the previous state and thus the
emulated TPM is unable to unseal the keys.

```shell
# Generate a new encryption key
SECRET="$(openssl rand -hex 64)"

# Register the new SVMS encryption state key
./register-resource-in-kbs.sh -p $(openssl rand -hex 64)

./start-cvm.sh
```

And the TPM is not able to unseal the secrets.

```shell
$ tpm2_load -C "$PRIMARY_CTX" -u seal.pub -r seal.priv -c seal.ctx
WARNING:esys:src/tss2-esys/api/Esys_Load.c:324:Esys_Load_Finish() Received TPM Error 
ERROR:esys:src/tss2-esys/api/Esys_Load.c:112:Esys_Load() Esys Finish ErrorCode (0x000001df) 
ERROR: Eys_Load(0x1DF) - tpm:parameter(1):integrity check failed
```
